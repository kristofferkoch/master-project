\section{Results and Discussion}

The emphasis of this project was not the AES module itself, but the
workflow outlined for specifying behaviour at a high level, and
obtaining a netlist correctly implementing the specified
behaviour.

\begin{table}[h]
  \centering
  \begin{tabular}{|c|c|}
    \hline
    \emph{Component}  & \emph{Count} \\ \hline
    AND2 & 8493 \\
    AND3 & 2 \\
    NAND2 & 501 \\
    NAND3 & 146 \\
    OR2 & 3982 \\
    OR3 & 39 \\
    NOR2 & 785 \\ 
    NOR3 & 1517 \\
    BUFF & 4131 \\
    INV & 560 \\
    AO22 & 692 \\
    AO222 & 8 \\
    C2 & 2609 \\
    C2R & 1093 \\
    C3  & 2130 \\
    AC2 & 0 \\
    \hline
  \end{tabular}
  \caption{Resource usage in terms of gates listed in
    figure~\ref{fig:teaklib} on page~\pageref{fig:teaklib}}
  \label{tab:res}
\end{table}

The Verilog netlist generated by Teak from the Balsa sourceode
contained 65421 lines. This also includes the test-bench enclosure,
inputting one key and plaintext, and printing the
ciphertext. Table~\ref{tab:res} summarizes the resource usage of the
Teak circuit, with the primitives illustrated in
figure~\ref{fig:teaklib} on page~\pageref{fig:teaklib}.

The performance was not measured, as this was a non-trivial procedure
with the choosen verilog simulator, which also prooved itself quite
unstable given the large verilog netlist. The litterature suggests
that my choices would yield a poorly performing circuit, as Teak has
been shown to currently perform worse than Balsa, which in turn
performs worse than conventional clocked circuits.

However, clockless circuits have other properties than clocked
circuits, which can be important for applications where performance is
not the primary objective. Low power is no longer considered a niche,
and as shown in \cite{claes}, clockless circuits can have good
characteristics with for secure implemetation of crypto algorithms.

It is also interesting how much effort that went into producing a
working AES module. I did not keep track of how many hours that went
into learning the Balsa language, or to write the AES, but after
understanding the basic handshake mechanisms, writing working Balsa
programs was quite straighforward. CSP languages, as noted in
\cite{taylor}, allows specifications to be expressed in way that is
similar to programmers accustomed to imperative programming languages,
such as C, lowering the threshold for doing hardware design, ``even
for novices''. While specifications written in CSP style languages
such as Balsa and Tangram are not guaranteed to be efficiently
implemented, tools such as visual simulators allows the designer to
gain a better understanding of how the design performs, find
bottlenecks and to optimize the sourcecode when required.

While low area and high performance are often cited goals for a
digital circuit specification, the time consumed by engineers to
design and verify a circuit is also important. If a design meets the
required constraints, e.g. it meet its realtime deadlies, and the
design fits on a specified FPGA, no further optimizations should be
required.

While I was able to develop an AES with the available tools, I
encountered bugs on many occasions, which I sometimes was not able to
work around. The most important problem was a compiler bug in Balsa
3.5.1, which prevented compilation of my AES module. I was later
supplied with the newest Balsa 4.0 which was able to generate
handshake circuits in the Breeze-format, but not able to further
generate netlists. While this illustrates that the choosen tools are
currently a bit immature, they are under development, and are expected
to improve.

