\section{Theory}

Usually, when designing digital circuits, two major simplifications
are made: 1) Signals are represented as digital values, and 2) the
time is divided into discrete steps by the means of a clock. The clock
defines the times when all data at registers are valid, and is set to
a period safe to all critical paths in the circuit.

When designing clockless circuits, the second simplification no longer
holds. The time is non-discrete, and a more concurrent understanding
is needed, with explicit synchronization between interacting signals
and calculations.

In this section, I will discuss the technical basis of clockless
design, while design tools for high level design will be discussed in
section~\ref{sec:tools}.

The strictest class of clockless circuits, delay insensive (DI)
circuits, assumes only bounded and positive, but unknown, delays in
wires and gates. Such circuits can only be constructed of C-elements
and inverters. The C-element shown in figure~\ref{fig:c}, and
variations of it, is often used in clocked circuits to provide storage
and correct sequencing in clockless protocols.

\begin{figure}[htbp]
  \centering
  \includegraphics{c.pdf}
  \caption{a) Symbol for a C-element, originally designed by David
    E. Muller. b) Truth-table c) Karnough-map d) Gate-level
    implementation. The C-element is the basis of many clockless
    constructs.}
  \label{fig:c}
\end{figure}

In \cite{dilimit} it is shown that it is impossible to create any
useful circuits with the restrictions of DI. The article suggests the
introduction of a timing assumption to facilitate the construction of
useful circuits: The isochronic fork.

\begin{figure}[htbp]
  \centering
  \includegraphics{fork.pdf}
  \caption{A fan-out, or ``fork'', showing wire delays. For the
    fork to be isochronic, the delays $d_b$ and $d_c$ must be equal.}
  \label{fig:fork}
\end{figure}

An isochronic fork is a timing assumption that requires a signal to be
delivered simultainiously to two circuit elements on a fanout such as
in figure~\ref{fig:fork}. This requirement requires attention in
implementation at the transistor level, but is not to hard to
fulfill. The isochronic fork allows the sender of a signal to assume
reception with acknowledgement from only one of the receivers. The
class of circuits depending on isochronic forks are said to be quasi
delay insensitive (QDI), and in \cite{turing} it is proved that any
turing computable function has a possible QDI implementation.

\begin{figure}[htbp]
  \centering
  \includegraphics{handshake.pdf}
  \caption{A clockless pipeline implemented with handshaking ensuring
    data validity. The channels are bundled data four phase push
    channels. Figure from \cite{sparso}.}
  \label{fig:handshake}
\end{figure}

To connect and synchronize blocks in a clockless circuits, a form of
handshaking is usually employed, often as as a request-acknowledge
protocol shown in figure~\ref{fig:handshake}. The handshaking provides
a local clock for the storage elements, usually latches or C-elements.

There are multiple ways to implement handshaking. Some high level
synthesis tools, introduced in section~\ref{sec:tools}, allows the
designer to choose and evaluate multiple implementation styles. The
Tangram/Haste synthesis tool allows handshake circuits to be
implemented as clocked circuits, making verification on regular FPGAs
possible.

\subsection{Encodings}

Clocked digital circuits often use regular binary encoding where one
wire corresponds to one bit, a high voltage corresponds to a 1 and a
low voltage to a 0. While this encoding is possible with clockless
circuits, it has the drawback of not indicating completion. Other
encodings, discussed below, can also provide completion detection, an
important property of a QDI design. Choice of encodings has also been
shown to have significant impact on power.
 
\begin{figure}[htbp]
  \centering
  \includegraphics{bundled.pdf}
  \caption{Bundled data XXX}
  \label{fig:bundled}
\end{figure}

When using bundled data, values are represented by conventional
boolean levels, and the handshaking is implemented by bundling request
and acknowledge signals with data as shown in
figure~\ref{fig:bundled}~a). Bundled data is also refered to as
single rail, in contrast to e.g. dual rail encoding, as data is
encoded as ordinary binary data. Usually there is no way to determine
wether binary data from a combinatonal function is complete, delays
matching the combinational delay in the critical path have to be
inserted in the control path to maintain correct behaviour as shown in
figure~\ref{fig:bundeled_delay}.

\begin{table}
  \centering
  \begin{tabular}{|c|c|}
    \hline
    \emph{Electrical signal} & \emph{Interpretation} \\
    \hline
    0 0 & ``NULL''; no value \\
    0 1 & false, 0 \\
    1 0 & true, 1 \\
    1 1 & invalid \\
    \hline
  \end{tabular}
  \label{tab:dr}
  \caption{Dual rail representation of a boolean value.}
\end{table}

If the signal is encoded into a representation using two wires per
bit, one for each value; logic 1 (true) and logic 0 (false), it is
possible to distinguish successive values by seperating them with an
``empty'' value, also referred to as a ``NULL''. This encoding is
referred to as ``dual rail'' encoding, and is summarized in
table~\ref{tab:dr}.

\begin{figure}[htbp]
  \centering
  \includegraphics{drgate.pdf}
  \caption{a) A dual rail inverter. b) A strongly indicating dual rail
    and-gate, and c) the simulated and-gate.}
  \label{fig:drgate}
\end{figure}

When implementing combinational functions for dual rail encoding, they
are typically split into two functions analogous to the pull up and
pull down networks in CMOS; one to compute the logic 0 or false value,
and one to compute the logic 1 or true value. A dual rail gate
implementation illustrating this is shown in figure~\ref{fig:drgate},
where one C-element is used to calculate a 1, and the other gates are
used to calculate a 0. Dual rail gates can often be less complex than
the example, by combining and optimizing the gates.

A more generalized method for encoding, is N of M encodings, where
dual rail is 1 of 2 encoding. All these encodings are constant-weight
(N) encodings, meaning that a complete signal has a certain hamming
weight, that is the count of electrical ones on a complete signal. In
\cite[chapter 9]{nullconv}, multiple of these encodings are surveyed
with regards to required resources (i.e. area) for wires and logic,
and power. An ALU for 1 of 4 encoding are shown to have good
characteristics in terms of power, area and performance, compared to
the dual rail encoding.

\subsection{Protocol}

When using handshake protocols, the handshake can be done in four or
two phases as shown in figure~\ref{fig:bundled}~b) and c). The four
phase protocol is also referred to as return to zero (RTZ). The two
phase protocol makes better use of the bandwith over the wires, but
usually the four phase protocol is preferred, as it allows for a
simpler implementation consuming less area.

In figure~\ref{fig:bundled}~a), a \emph{push} channel is shown. This
means that the data source initiates the handshake with the request
signal, as opposed to when the receiver inititates it. A channel where
the receiver initiates the handshake is referred to as a \emph{pull}
channel.

\begin{figure}[htbp]
  \centering
  \includegraphics{compdet.pdf}
  \caption{A memory element with completion detection. Figure from
    \cite[pp. 21]{sparso}.}
  \label{fig:compdet}
\end{figure}

In the case of QDI (e.g. dual-rail) encodings, completion detection
provides either the request or acknowledge signal. Completion is
detected by counting the number of electrical ones, as shown in
figure~\ref{fig:compdet}, providing either a request signal in the
case of a push channel, or an acknowledge signal in the case of a pull
channel. The completion detector in figure~\ref{fig:compdet} provides
the request signal, and is therefore the receiver in a push channel.

Using dual rail encoding usually also implies using the four phase
protocol\footnote{For the sake of completeness, two phase protocol is
  possible with level-encoded two phase dual-rail (LEDR)\cite{ledr},
  but it is considered impractical for other uses than on long wires
  on chip.}  (figure~\ref{fig:bundled}~b)), as the combinational
circuits must return to the NULL state between values to distinguish
successive values on the channel. Care must therefore not only be
taken to avoid hazards on NULL-to-value transitions, but also on the
return-to-NULL transitions.

Hazards are avoided by adding redundant gates XXX

\subsection{XXX}

XXX mention Fant advanced pipelining, williams bubbles etc?

XXX summary
