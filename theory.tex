\section{Theory}

Usually, when designing digital circuits, two major simplifications
are made: Signals are represented as digital values, and the time is
divided into discrete steps by the means of a clock. The clock defines
the times when all data at registers are valid, and is set to a
period safe to all critical paths in the circuit.

When designing clockless circuits, the second simplification no longer
holds. The time is non-discrete, and a more concurrent understanding
is needed, with explicit synchronization between interacting signals
and calculations.

In this section, I will discuss the technical basis of clockless
design, while design tools for high level design will be discussed in
section~\ref{sec:tools}.

The strictest class of clockless circuits, delay insensive (DI)
circuits, assumes only bounded and positive, but unknown, delays in
wires and gates. Such circuits can only be constructed of C-elements
and inverters. The C-element shown in figure~\ref{fig:c}, and
variations of it, is often used in clocked circuits to provide storage
and correct sequencing in clockless protocols.

\begin{figure}[htbp]
  \centering
  \includegraphics{c.pdf}
  \caption{a) Symbol for a C-element, originally designed by David
    E. Muller. b) Truth-table c) Karnough-map d) Gate-level
    implementation. The C-element is the basis of many clockless
    constructs.}
  \label{fig:c}
\end{figure}

In \cite{dilimit} it is shown that it is impossible to create any
useful circuits with the restrictions of DI. The article suggests the
introduction of a timing assumption to facilitate the construction of
useful circuits: The isochronic fork.

\begin{figure}[htbp]
  \centering
  \includegraphics{fork.pdf}
  \caption{A fan-out, or ``fork'', showing wire-delays delays. For the
    fork to be isochronic, the delays $t_b$ and $t_c$ must be equal.}
  \label{fig:fork}
\end{figure}

An isochronic fork is a timing assumption that requires a signal to be
delivered simultainiously to two circuit elements on a fanout such as
in figure~\ref{fig:fork}. This requirement requires attention in
implementation at the transistor level, but it XXX easy. The
isochronic fork allows the sender of a signal to assume reception with
acknowledgement from only one of the receivers. The class of circuits
depending on isochronic forks are said to be quasi delay insensitive
(QDI), and in \cite{turing} it is proved that any turing computable
function has a QDI implementation.

\begin{figure}[htbp]
  \centering
  \includegraphics{handshake.pdf}
  \caption{A clockless pipeline implemented with handshaking ensuring
    data validity. The channels are bundled data four phase push
    channels. Figure from \cite{sparso}.}
  \label{fig:handshake}
\end{figure}

To connect and synchronize blocks in a clockless circuits, a form of
handshaking is usually employed, often as as a request-acknowledge
protocol shown in figure~\ref{fig:handshake}. The handshaking provides
a local clock for the storage elements, usually latches or C-elements.

There are multiple ways to implement handshaking. Some high level
synthesis tools, introduced in section~\ref{sec:tools}, such as Balsa,
allows the designer to choose and evaluate multiple implementation
styles. The Tangram/Haste language allows handshake circuits to be
implemented as clocked circuits, making verification on regular FPGAs
possible.

\subsection{Encodings}

Clocked digital circuits often use regular binary encoding where one
wire corresponds to one bit, a high voltage corresponds to a 1 and a
low voltage to a 0. While this encoding is possible with clockless
circuits, it has the drawback of not indicating completion. Other
encodings, discussed below, can also provide completion detection, an
important property of a QDI design. Choice of encodings has also been
shown to have significant impact on power.
 
\begin{figure}[htbp]
  \centering
  \includegraphics{bundled.pdf}
  \caption{Bundled data XXX}
  \label{fig:bundled}
\end{figure}

When using bundled data, values are represented by conventional
boolean levels, and the handshaking is implemented by bundeling the
request and acknowledge signals with the data as shown in
figure~\ref{fig:bundled}~a). Bundled data is also refered to as
single-rail, in contrast to dual or N-of-M rail encodings, as data is
encoded as ordinary binary data.

As there usually are no way to determine wether binary data from a
combinatonal function is complete, delays matching the combinational
delay have to be inserted in the control path to maintain correct
behaviour as shown in figure~\ref{fig:bundeled_delay}.

When using handshake protocols, the handshake can be done in four or
two phases as shown in figure~\ref{fig:bundled}~b) and c). The four
phase protocol is also referred to as return to zero (RTZ). The two
phase protocol makes better use of the bandwith over the wires, but
usually the four phase protocol is preferred, as it allows for a
simpler implementation consuming less area.

In figure~\ref{fig:bundled}~a), a \emph{push} channel is shown. This means
that the data source initiates the handshake, as opposed to when the
consumer inititates it. A channel where the consumer initiates the
handshake is referred to as a \emph{pull} channel.

XXX Indication and the muller-C element

If the signal is encoded into a representation using two wires per
bit, one for each value; logic 1 (true) and logic 0 (false). This
redundant representation provides the possibility of a variable to
have an ``empty'' value, also referred to as a NULL. 

\begin{figure}[htbp]
  \centering
  \includegraphics{compdet.pdf}
  \caption{A memory element with completion detection. Figure from
    \cite[pp. 21]{sparso}.}
  \label{fig:compdet}
\end{figure}

When implementing combinational functions for dual rail encoding, they
are typically split into two functions analogous to the pull up and
pull down networks in CMOS; one to compute the logic 0 or false value,
and one to compute the logic 1 or true value. Completion is detected
by counting the number of electrical ones, as shown in
figure~\ref{fig:compdet}, providing either a request signal in the
case of a push channel, or an acknowledge signal in the case of a pull
channel. The completion detector in figure~\ref{fig:compdet} is a part
of a push channel, as the data provides the request.

\begin{figure}[htbp]
  \centering
  \includegraphics{drgate.pdf}
  \caption{a) A dual rail inverter. b) A strongly indicating dual rail
    and-gate.}
  \label{fig:drgate}
\end{figure}


Using dual rail encoding also implies using the four phase protocol
(figure~\ref{fig:bundled}~b)), as the combinational circuits must
return to the NULL state between values to distinguish successive
values on the channel. Care must therefore not only be taken to avoid
hazards on NULL-to-value transitions, but also on the return-to-NULL
transitions.

XXX LEDR: http://portal.acm.org/citation.cfm?id=112078

Hazards are avoided by adding redundant gates XXX

A more generalized method for encoding, is N of M encodings, where
dual rail is 1 of 2 encoding. All these encodings are constant-weight
encodings, meaning that a complete signal has a certain hamming
weight, or count of electrical ones. In \cite[chapter 9]{nullconv},
multiple of these encodings are surveyed with regards to required
resources (i.e. area) for wires and combinations, and power. An ALU
for 1 of 4 encoding are shown to have good characteristics in terms of
power, area and performance, compared to the dual rail encoding.

XXX mention Fant advanced pipelining, williams bubbles etc?

XXX summary
